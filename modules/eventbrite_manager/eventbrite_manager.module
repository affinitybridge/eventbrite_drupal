<?php
// $Id$

//==========================================//
// CORE HOOKS
//==========================================//

/**
 * Implementation of hook_init().
 * 
 * This hook will bring in the eventbrite_cck stylesheet
 */
function eventbrite_manager_init() {
  drupal_add_css(drupal_get_path('module', 'eventbrite_manager')  .'/eventbrite_manager.css');
}

/**
 * Implementation of hook_theme().
 */
function eventbrite_manager_theme() {
  $path = drupal_get_path('module', 'eventbrite_manager');
  
  $base = array(
    'file' => 'theme.inc',
    'path' => "$path/theme",
  );
  
  return array(
    'eventbrite_manager_formatter_default' => $base + array(
      'arguments' => array('element' => NULL)
    ),
    'eventbrite_manager_event_widget' => $base + array(
      'arguments' => array('element' => NULL),
    ),
    'eventbrite_manager_event' => $base + array(
      'arguments' => array('event' => NULL),
      'template' => 'eventbrite-manager-event'
    ),
  );
}

//==========================================//
// CCK FIELD HOOKS
//==========================================//
/**
 * Implementation of hook_field_info().
 */
function eventbrite_manager_field_info() {
  return array(
    // Defining Eventbrite Event field
    'eventbrite_manager' => array(
      'label' => t('Eventbrite Manageable Event'),
      'description' => t('Associate a manageable Eventbrite event with a node.'),
    ),
  );
}

/**
 * Implementation of hook_field_settings().
 */
function eventbrite_manager_field_settings($op, $field) {
  switch ($op) {
  	// TODO: There will be settings that go on this form
  	//
  	// -default date stuff likely
  	//       (Maybe we will have to come up with some)  	
    /* 
    // 'form' and 'save' ops may not be needed for this field
    // 
    // Create the form element to be used on the field 
    // settings form. Field settings will be the same for 
    // all shared instances of the same field and should 
    // define the way the value will be stored 
    // in the database.
    case 'form':
      $form = array();
      $form['max_length'] = array(
        '#type' => 'textfield',
        '#title' => t('Maximum length'),
        '#default_value' => is_numeric($field['max_length']) ? $field['max_length'] : 255,
        '#required' => FALSE,
        
        // Use #element_validate to validate the settings.
        '#element_validate' => array('_example_length_validate'),
        '#description' => t('The maximum length of the field in characters. Must be a number between 1 and 255'),
      );
      return $form;

    // Return an array of the names of the field settings 
    // defined by this module. These are the items that 
    // CCK will store in the field definition
    // and they will be available in the $field array.
    // This should match the items defined in 'form' above.

    case 'save':
      return array('max_length');
    */
  	
    // Define the database storage for this field
    case 'database columns':
      $columns['ebid'] = array(
        'type' => 'int', 
        'unsigned' => TRUE,
        'not null' => FALSE,
        'default' => 0,
        'sortable' => TRUE, 
        'views' => TRUE,
      );
      $columns['title'] = array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE, 
        'default' => '',
        'sortable' => TRUE, 
        'views' => TRUE,
      );
      $columns['description'] = array(
        'type' => 'text',
        'default' => '',
        'views' => TRUE,
        'not null' => FALSE, 
      );
      
      $columns['start_date'] = array(
        'type' => 'datetime',
        'not null' => FALSE,
        'sortable' => TRUE,
        'views' => TRUE,
      );

      $columns['end_date'] = array(
        'type' => 'datetime',
        'not null' => FALSE,
        'sortable' => TRUE,
        'views' => TRUE,
      );

      $columns['timezone'] = array(
        'type' => 'varchar',
        'length' => 50,
        'not null' => FALSE,
        'sortable' => FALSE,
        'views' => TRUE,
      );
      
      $columns['offset'] = array(
        'type' => 'int',
        'not null' => FALSE,
        'sortable' => FALSE,
        'views' => FALSE,
      );
      
      return $columns;

    // TODO: Decide if any changes need to be made to the default $data array created for Views.
    case 'views data':
      // Start with the $data created by CCK
      // and alter it as needed. The following
      // code illustrates how you would retrieve
      // the necessary data.
      
      $data = content_views_field_views_data($field);
      $db_info = content_database_info($field);
      $table_alias = content_views_tablename($field);

      // Make changes to $data as needed here.
      //$field_data = $data[$table_alias][$field['field_name'] .'_ebid'];
      
      return $data;
      
  }
}

/**
 * Implementation of hook_field().
 */
function eventbrite_manager_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {
    // Do validation on the field values here. The widget 
    // will do its own validation and you cannot make any 
    // assumptions about what kind of widget has been used, 
    // so don't validate widget values, only field values.
    
    case 'validate':
    	drupal_set_message('here');
      if (is_array($items)) {
        foreach ($items as $delta => $item) {
          // DO validation here for the field
          
          // If the field is empty just skip, wasn't filled in, that is valid
          if (eventbrite_manager_content_is_empty($item, $field)) {
          	return $items;
          }
          if (isset($item['ebid']) && !empty($item['ebid'])) {
          	// EB_ID is set, that means all required field elements need to be set as well
          	if (empty($item['title'])) {
              form_set_error($field['field_name'], t('The title field is required'));
              return false;
          	}
          	// description can be empty
          	if (empty($item['start_date']) || empty($item['end_date'])) {
              form_set_error($field['field_name'], t('The date fields are required'));
              return false;
           	}
          }
          else {
          	/* Not sure about this one
          	// EB ID is blank, that means everything else should be blank
          	 * Should we set an error if EB is blank and other fields have values?
          	if (!empty($item['title'])) {
              form_set_error($field['field_name'], t('No ebid, so title should be empty'));
              return false;
           	}
           	*/
          }

          // TODO: Add some of this date stuff back in later if there is a need
          /*
          // Don't try to validate if there were any errors before this point since the element won't have been munged back into a date.
          // TODO: Can probably remove the if !form_get_errors() as we're returning if there are any errors
          
          if (!form_get_errors()) {
            foreach ($items as $delta => $item) {
              $process = date_process_values($field);
              foreach ($process as $processed) {
                $error_field = $field['field_name'] .']['. $delta .']['. $processed;
                // Not sure that this next line needs to be in here
                $error_field .= $field['widget']['type'] == 'date_select' ? '][year' : '';
                // $field['todate'] will always be required, these validation routines should be simpler
                if ($processed == 'start_date' && $field['todate']
                  && !date_is_valid($item['start_date'], $field['type'], $field['granularity'])
                  && (date_is_valid($item['end_date'], $field['type'], $field['granularity']))) {
                  form_set_error($error_field, t("A 'From date' date is required for field %field %delta.", array('%delta' => $field['multiple'] ? intval($delta + 1) : '', '%field' => t($field['widget']['label']))));
                }
                if ($processed == 'end_date'
                  && $field['todate'] == 'required' && ($field['required']
                  && date_is_valid($item['start_date'], $field['type'], $field['granularity'])
                  && !date_is_valid($item['end_date'], $field['type'], $field['granularity']))) {
                  form_set_error($error_field, t("A 'To date' is required for field %field %delta.", array('%delta' => $field['multiple'] ? intval($delta + 1) : '', '%field' => t($field['widget']['label']))));
                }
              }
            }
          }
          */
          
          /* TODO: Should we checking that ebid is valid?  Widget will not allow for editing of this value, so should be good
          // Check to see that this is a gettable event
          if (!eventbrite_get('event_get', $item['ebid'])) {
            form_set_error($field['field_name'], t('"%ebid" is not a valid event id in the Eventbrite system', array('%ebid' => $item['ebid'])));
            return false;
          }
          */

        }
      }
      return $items;

    // This is where you make sure that user-provided data is sanitized before being displayed.
    case 'sanitize':
      // TODO: this should be replaced to sanitize calls to the actual field item keys.
      foreach ($items as $delta => $item) {
        foreach ( $item as $col => $dat ) {
          $items[$delta]['safe_' . $col ] = check_plain($item[ $col ]);
        }
      }
      break;
    
    case 'presave':
      if (is_array($items) && !empty($items)) {
        foreach ($items as $delta => $item) {
          // If the field is empty just skip, wasn't filled in, that is valid
          if (eventbrite_manager_content_is_empty($item, $field)) {
          	continue;
          }

          $event = new stdClass();
          $event->title = $item['title'];
          $event->description = $item['description'];
          $event->start_date = $item['start_date'];
          $event->end_date = $item['end_date'];

          // Calculate timezone and offset
          $start_date = date_create($item['start_date'], timezone_open($item['timezone']));
          $items[$delta]['offset'] = $offset = $start_date->getOffset() / 3600;
          $event->timezone = eventbrite_timezone_offset($items[$delta]['offset']);

          if ($item['ebid']) {
          	// There is an ebid, which means that an edit/update needs to happen
          	$event->event_id = $item['ebid'];
          	
          	// TODO: This function should return an event, which will need to be parsed (and cleaned) before save
          	if ($event = eventbrite_save('event_update', $event)) {
              drupal_set_message(t('This event was successfully updated'));
              // TODO: parse and clean the event
              // TODO: update field items with values from the server, even if it doesn't matter and they won't change
            }
            else {
              // Save request could not be completed
              // TODO: set a form error here so that the field does not validate (rather than dsm())
              if ($errors = eventbrite_errors()) {
                foreach ($errors as $error_type => $error_msg) {
                  drupal_set_message($error_type .': '. $error_msg, 'error');
                }
              }
              drupal_set_message('Could not update the event', 'error');
            }          	
          }
          else {
          	// There is no ebid, which means event needs to be created
          	if ($event = eventbrite_save('event_new', $event)) {
              drupal_set_message(t('The new event was successfully created - '.$event->id));

              // TODO: Figure out which of these calls are actually putting the variable in and remove cruft
              // TODO: parse and clean the event
              // TODO: Now that eventbrite_save returns an event object and not an event_id, all of these field
              //         items should be updated
              $items[$delta]['ebid'] = $event->id;
              $node_field = $node->$field['field_name'];
              $node_field[$delta]['ebid'] = $event->id;
              $node->$field['field_name'] = $node_field;
          	}
            else {
            	// TODO: set a form error here so that the field does not validate (rather than dsm())
              drupal_set_message('Could not create the event', 'error');
            }
          }
        }
      }
      break; 
  }
  
  return $items;
}

/**
 * Implementation of hook_content_is_empty().
 * 
 * CCK has no way to know if something like a zero is
 * an empty value or a valid value, so return
 * TRUE or FALSE to a populated field $item array.
 * CCK uses this to remove empty multi-value elements
 * from forms.
 */
function eventbrite_manager_content_is_empty($item, $field) {
  if (empty($item['ebid']) && empty($item['title'])) {
    return TRUE;
  }
}

function eventbrite_manager_default_value(&$form, &$form_state, $field, $delta) {
  return array();
}

//==========================================//
// CCK FIELD WIDGET HOOKS
//==========================================//

/**
 * Implementation of hook_widget_info().
 */
function eventbrite_manager_widget_info() {
  return array(
    // Event ID widget allows user to enter an Eventbrite event id into a textfield
    'eventbrite_manager_event_widget' => array(
      'label' => t('Eventbrite Manager widget'),
      'field types' => array('eventbrite_manager'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
      'description' => 'An Edit widget that allows users to create and edit events',
    ),
  );
}

/**
 * Implementation of hook_elements().
 */
function eventbrite_manager_elements() {
  $elements = array(
    'eventbrite_manager_event_widget' => array(
      '#input' => TRUE,
      '#process' => array('eventbrite_manager_event_widget_process' ),
      '#element_validate' => array('eventbrite_manager_event_widget_validate'),
    ),
  );

  return $elements;
}

function eventbrite_manager_event_widget_process($element, $edit, &$form_state, $form) {
  // TODO: This was from date, not sure it's needed
  if (isset($element['#access']) && empty($element['#access'])) {
    return $element;
  }

  // Make sure ebid gets set (it seems to require special handling)
  $defaults = $element['#value'];
  if (isset($element['#default_value']['ebid'])) {
  	$defaults['ebid'] = $element['#default_value']['ebid'];
  }
  $field_name = $element['#field_name'];
  
  $field = content_fields($field_name, $element['#type_name']);
  $delta = $element['#delta'];
  
  $element['ebid'] = array(
    '#type' => 'value',
    '#value' => $defaults['ebid'],
  );

  $element['title'] = array(
    '#title' => t('Title'),
    '#type' => 'textfield',
    '#default_value' => $defaults['title'],
    '#size' => 60,
    '#maxlength' => 255,
    '#weight' => 0,
    '#required' => $element['#required'],
  );

  $element['description'] = array(
    '#title' => t('Description'),
    '#type' => 'textarea',
    '#default_value' => $defaults['description'],
    '#weight' => 1,
  );
  
  // TODO: Add configurability for default date values
  
  // For now, set default event date 30 days in the future
  $default_ts = time() + (60 * 60 * 24 * 30);
  $default_datetime = date_convert($default_ts, DATE_UNIX, DATE_DATETIME);
  list($default_date) = explode(' ', $default_datetime);
  
  $default_start_datetime = $default_date .' '. '18:00';
  $default_end_datetime = $default_date .' '. '21:00';
  
  $element['start_date'] = array(
    '#title' => t('Start date'),
    '#field' => $field,
    // TODO: Admins should be able to chose date_select or date_popup on field admin form
    //       Right now we are assuming date_select everywhere
    '#type' => 'date_select',
    '#default_value' => isset($element['#value']['start_date']) ? $element['#value']['start_date'] : $default_start_datetime,
    '#weight' => 2,
    '#required' => 1,
    '#delta'         => $delta,
    // TODO: #date_formet should not be coming from a variable, it should come from a value on field settings form
    //       Not sure how to work granularity in like this code does:
    //       '#date_format' => date_limit_format(date_input_format($element, $field), $field['granularity']),  
    '#date_format' => variable_get('eventbrite_manager_default_date_format', 'F-d-Y h:iA'),
    // TODO: Add something about #date_timezone
    '#date_timezone' => $element['#date_timezone'],
    '#date_text_parts'  => array(),
    '#date_increment'   => 5,
    '#date_year_range'  => '0:+1',
    '#date_label_position' => 'none',
  );

  // TODO: Add support for date_popup (not just date_select)
  //    date_popup may need #date_titme field filled in on date elements- see date_elements.inc line 338
  
  // This allows date elements to float on the same line
  //   Must be for date_popup as it doesn't do anything with date_select
  // $element['#date_float'] = TRUE;
  
  // Populate end date with start date values
  $element['end_date'] = $element['start_date'];
  $element['end_date']['#title'] = t('End date');
  $element['end_date']['#default_value'] = isset($element['#value']['end_date']) ? $element['#value']['end_date'] : $default_end_datetime;
  $element['end_date']['#weight'] += .5;
  
  // TODO: Add user timezone to the mix, currently default is site default
  $element['timezone'] = array(
    '#type' => 'date_timezone',
    '#options' => date_timezone_names($element['#required']),
    '#weight' => 3,
    '#default_value' => isset($element['#value']['timezone']) ? $element['#value']['timezone'] : variable_get('date_default_timezone_name', ''),//$default_start_datetime,
    // Timezone may need to allow blank timezone labels and would then not support being required
    '#required' => 1, //$element['#required'],
  );

  // Date had this, may as well leave it in
  // Make sure field info will be available to the validator which does not get the values in $form.
  $form_state['#field_info'][$field['field_name']] = $field;

  return $element;
}

function eventbrite_manager_event_widget_validate(&$element, &$form_state) {
  // Standard widget validate stuff
  $form_values = $form_state['values'];
  $field_name = $element['#field_name'];
  $delta = $element['#delta'];
  $field = $form_state['#field_info'][$field_name];
  
  // TODO: See if this is needed
  // If the whole field is empty and that's OK, stop now.
  if (empty($element['#post'][$field_name]) && !$element['#required']) {
  	drupal_set_message('LOOKY LOOKY NOTE: This chunk got called');
    return;
  }
  
  // If ebid and title are both empty then consider the field empty (no validation needed)
  if (empty($element['ebid']['#value']) && empty($element['title']['#value'])) {
  	drupal_set_message('Empty widget at delta '.$delta);
  	return;
  }
  
  if (empty($element['title']['#value'])) {
  	// TODO: Figure out a way for this form_set_error to be put on just the title field for this delta value
    // TODO: add $delta value to error msg
  	form_set_error($field_name, t('The title field is required for event submission in !field_label', array('!field_label' => $field['widget']['label'])));
  }

  // Date items and timezone are #required so no need here to look for them
  
  // TODO: Add in a call to date_popup_input_value (this coe is from date_select_input_value
  // These are DATETIME strings (ISO dates)
  $start_date = date_select_input_value($element['start_date']);
  $end_date = date_select_input_value($element['end_date']);
  
  if ($start_date > $end_date) {
      // TODO: no real need to call form_set_value()
//      form_set_value($element['end_date'], 'end_date', $form_state);
    // TODO: add $delta value to error msg
    form_set_error($field_name, t('The end date field must be greater than the start date field in !field_label', array('!field_label' => $field['widget']['label'])));
  }

  // Don't look for further errors if errors are already flagged
  // because otherwise we'll show errors on the nested elements
  // more than once. (?)
  if (form_get_errors()) {
  	return;
  }

  // TODO: probably shouldn't return here, should do more date processing
  //       just making sure that, for now, we don't need the form_set_value()s for any processing
  return;

  // TODO: Check out how date provides alternate error reporting:
  // Unfortunately, due to the fact that much of the processing is already
  // done by the time we get here, it is not possible highlight the field
  // with an error, we just try to explain which element is creating the
  // problem in the error message.
  $parent = $element['#parents'];
  $error_field = array_pop($parent);
  $errors = array();

  // TODO: Add in a call to date_popup_input_value (this coe is from date_select_input_value
  // These are DATETIME strings (ISO dates)
  $from_date = date_select_input_value($element['start_date']);
  $to_date = date_select_input_value($element['end_date']);
    
  // TODO: Check for date validity--most of this is probably not needed
  $from_field = 'start_date';
  $to_field = 'end_date';
  $tz_field = 'timezone';
  $offset_field = 'offset';
  $offset_field2 = 'offset2';
  
  // Convert input dates back to their UTC values and re-format to ISO
  // or UNIX instead of the DATETIME format used in element processing.
  $timezone = !empty($item['timezone']) ? $item['timezone'] : $element['#date_timezone'];
  $timezone_db = date_get_timezone_db($field['tz_handling']);
  // Not sure why timezone would be added back into the form here--doesn't make much sense
  $item[$tz_field] = $timezone;

  // Check date to make offset field
  $from_date = date_make_date($from_date, $timezone);
  $item[$offset_field] = date_offset_get($from_date);    
  $to_date = date_make_date($to_date, $timezone);
  $item[$offset_field2] = date_offset_get($to_date);

  // Get test dates in this timezone, to make sure that dates are valid
  //   (do this before changing the timezone to the db
  $test_from = date_format($from_date, 'r');
  $test_to = date_format($to_date, 'r');

  // Put the dates back into the form as UTC?
  // This can be skipped if timezones are set properly in the widget
  date_timezone_set($from_date, timezone_open($timezone_db));
  date_timezone_set($to_date, timezone_open($timezone_db));
  $item[$from_field] = date_format($from_date, date_type_format($field['type']));
  $item[$to_field] = date_format($to_date, date_type_format($field['type']));
      
  // Test a roundtrip back to the original timezone to catch
  // invalid dates, like 2AM on the day that spring daylight savings
  // time begins in the US.
  date_timezone_set($from_date, timezone_open($timezone));
  date_timezone_set($to_date, timezone_open($timezone));
  if ($test_from != date_format($from_date, 'r')) {
    $errors[] = t('The From date is invalid.');
  }
  if ($test_to != date_format($to_date, 'r')) {
    $errors[] = t('The To date is invalid.');
  }
  
  if (empty($errors)) {
  	// TODO: Not sure why we need to copy this element back into the form
//    form_set_value($element, $item, $form_state);
    return;
  }
  else {
    if ($field['multiple']) {
      form_set_error($error_field, t('There are errors in @field_name value #@delta:', array('@field_name' => $field['widget']['label'], '@delta' => $delta + 1)) . theme('item_list', $errors));
    }
    else {
      form_set_error($error_field, t('There are errors in @field_name:', array('@field_name' => $field['widget']['label'])) . theme('item_list', $errors));      
    }
  }
  
  /*
  // TODO: Should we check the ebid, if there is one, to see if it is a gettable event
  if (!eventbrite_get('event_get', $event_id)) {
  	form_set_error(
      $element, 
      t(
        'The Eventbrite event id you entered (%ebid) for %field field is not a valid event id in the Eventbrite system',
        array('%ebid' => $event_id, '%field' => $ftitle)
      )
    );
  }
  */
  
}

/**
 * Implementation of hook_widget().
 */
function eventbrite_manager_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  module_load_include('inc', 'date_api', 'date_api_elements.inc');

  // TODO: remove switch statement if this ends up being the only widget defined by eventbrite_manager
  switch ($field['widget']['type']) {
    case 'eventbrite_manager_event_widget':
      $element = array(
        '#type' => 'eventbrite_manager_event_widget',
        '#default_value' => isset($items[$delta]) ? $items[$delta] : array(),
      );
      
      // TODO: This stuff can be very likely gotten rid of
      /*
      foreach (array('start_date', 'end_date') as $processed) {
        if (!isset($items[$delta][$processed])) {
          $items[$delta][$processed] = '';
        }
        $date = date_local_date($form, $form_state, $delta, $items[$delta], $timezone, $field, $processed);
    
        $items[$delta][$processed] = is_object($date) ? date_format($date, DATE_FORMAT_DATETIME) : '';
      }
      */
      break;
  }
    
  return $element;
}


//==========================================//
// CCK FIELD FORMATTER HOOKS
//==========================================//
/**
 * Implementation of hook_field_formatter_info().
 */
function eventbrite_manager_field_formatter_info() {
  return array(
    // Default formatter - Event details
    'default' => array(
      'label' => t('Event details'),
      'field types' => array('eventbrite_manager'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
  );
}

